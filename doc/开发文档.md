# DEVELOPMENT.md（完整开发文档）

## 1. 目标与范围（V0.1 MVP）

V0.1 目标：**实现设备上线 + 下发移动/停止/表情 + 回执闭环 + 遥测上报**
V0.1 不做：语音、视觉、复杂避障、完整 OTA、完整 MQTT Broker 功能

---

## 2. 仓库结构建议（推荐单仓多模块）

建议用 Maven/Gradle 多模块（示例）：

```
deskpet/
  docs/
    ARCHITECTURE.md
    DEVELOPMENT.md
  mqtt-gateway/          # Vert.x
  pet-core/              # Spring Boot
  pet-ai/                # (后期) Spring Boot + Spring AI
  device-firmware/       # ESP32/MCU 工程（可单独仓库也行）
  deploy/
    docker-compose.yml
    nginx/ (可选)
```

---

## 3. 技术栈与约定

### 3.1 技术栈

* mqtt-gateway：Vert.x（MQTT Server）
* pet-core：Spring Boot（REST API + JPA/MyBatis）
* DB：PostgreSQL（推荐）或 MySQL
* Redis：可选（最新遥测缓存、分布式锁、在线映射后期用）
* JSON：统一使用 UTF-8 JSON

### 3.2 基础约定

* **deviceId**：全局唯一（建议 `pet001` 这种）
* **reqId**：UUID（强制；用于幂等、追踪、审计）
* **schemaVersion**：从 1 开始（便于协议升级）

---

## 4. MQTT Topic 与 ACL（V0.1 固定）

### 4.1 Topic

* 设备订阅：

  * `pet/{deviceId}/cmd`
* 设备发布：

  * `pet/{deviceId}/telemetry`
  * `pet/{deviceId}/cmd/ack`
  * `pet/{deviceId}/presence`（可选）

### 4.2 QoS

* cmd：QoS1
* cmd/ack：QoS1
* telemetry：QoS0（关键状态可升级 QoS1）

### 4.3 ACL 校验规则（网关实现）

设备连接后，网关必须校验：

* clientId == deviceId
* publish topic 只能是 `pet/{deviceId}/telemetry`、`pet/{deviceId}/cmd/ack`（以及 presence）
* subscribe topic 只能是 `pet/{deviceId}/cmd`

> 这样你不需要实现复杂 broker 路由，安全边界也清晰。

---

## 5. 消息协议（统一信封）

### 5.1 命令（Core → Device）

Topic：`pet/{deviceId}/cmd`

```json
{
  "schemaVersion": 1,
  "type": "move",
  "reqId": "uuid",
  "ts": 1730000000,
  "payload": {
    "direction": "forward",
    "speed": 0.6,
    "durationMs": 800
  }
}
```

#### type 列表（V0.1）

* `move`

  * direction：`forward|backward|left|right`
  * speed：0.0 ~ 1.0（设备端要二次限幅）
  * durationMs：建议 50 ~ 5000
* `stop`

  * payload 可为空
* `setEmotion`

  * emotion：`idle|happy|sad|angry|sleepy`
  * durationMs：可选

### 5.2 回执（Device → Core）

Topic：`pet/{deviceId}/cmd/ack`

```json
{
  "schemaVersion": 1,
  "reqId": "uuid",
  "ok": true,
  "code": "DONE",
  "message": "moved forward",
  "ts": 1730000002
}
```

#### code 建议枚举

* `DONE`
* `BAD_PAYLOAD`
* `SAFETY_LIMIT`
* `BUSY`
* `INTERNAL_ERROR`

### 5.3 遥测（Device → Core）

Topic：`pet/{deviceId}/telemetry`

```json
{
  "schemaVersion": 1,
  "ts": 1730000000,
  "firmwareVersion": "0.1.0",
  "rssi": -55,
  "battery": 0.87,
  "lastAction": "move"
}
```

---

## 6. pet-core（Spring Boot）设计

### 6.1 模块划分

* `DeviceService`

  * 注册、secret 管理（hash）、查询在线、查询最新遥测
* `CommandService`

  * 创建命令（PENDING）
  * 下发命令（调用网关）→ SENT
  * 处理 ack → ACKED/FAILED
  * 超时扫描 → TIMEOUT
* `TelemetryService`

  * 遥测写入 latest +（可选）历史表/TSDB
* `GatewayClient`

  * 内部调用网关 API：sendCommand
* `ApiController`

  * 对外 API（console/app）
* `InternalController`

  * 给网关回调用（telemetry、ack、online/offline）

### 6.2 数据库表（V0.1 最小）

**device**

* device_id (PK)
* secret_hash
* model
* remark
* created_at

**device_session**

* device_id (PK)
* online
* gateway_instance_id (nullable)
* ip
* last_seen

**command**

* req_id (PK)
* device_id (FK)
* type
* payload_json
* status (PENDING/SENT/ACKED/FAILED/TIMEOUT)
* ack_code (nullable)
* ack_message (nullable)
* created_at
* updated_at

**telemetry_latest**

* device_id (PK)
* telemetry_json
* updated_at

> 遥测历史（telemetry_history）V0.1 可以不做，先把最新状态跑通。

### 6.3 对外 REST API（V0.1）

OpenAPI 文档：启动 `pet-core` 后访问 `http://localhost:8080/swagger-ui/index.html`，或查看 `doc/对外API文档.md`。

#### 设备

* `GET /api/devices`
* `GET /api/devices/{deviceId}`（含在线、latest telemetry）
* `POST /api/devices`（注册设备：deviceId + secret）

#### 指令

* `POST /api/devices/{deviceId}/commands`

  * 请求：

    ```json
    { "type": "move", "payload": { "direction": "left", "speed": 0.4, "durationMs": 500 } }
    ```
  * 响应：

    ```json
    { "reqId": "uuid", "status": "PENDING" }
    ```

* `GET /api/devices/{deviceId}/commands/{reqId}`

* `POST /api/devices/{deviceId}/commands/{reqId}/retry`

  * 说明：仅 `TIMEOUT/FAILED` 可重试（默认不自动重试）
  * 响应：同指令查询

> V0.1 先用“轮询 GET 指令结果”就够了；后面再做 SSE/WS。

错误响应格式与错误码见 `doc/错误码文档.md`。

### 6.4 内部回调 API（网关 → Core）

* `POST /internal/telemetry/{deviceId}`
* `POST /internal/ack/{deviceId}`
* `POST /internal/gateway/deviceOnline`
* `POST /internal/gateway/deviceOffline`

内部接口必须：

* 只监听内网
* 或加内部 token（如 `X-Internal-Token`）

### 6.5 指令状态机与超时

* 创建：`PENDING`
* 网关下发成功：`SENT`
* 收到 ack：

  * ok=true → `ACKED`
  * ok=false → `FAILED`
* 超时任务（建议每 1s~5s 扫描）：

  * `SENT` 超过 `commandTimeoutSec`（默认 10s）→ `TIMEOUT`

**重试策略（V0.1 建议先不做自动重试）**
先把状态打通。等 V0.2 再加：

* TIMEOUT 后允许人工重试
* 或自动重试 1 次（仍沿用 reqId 或生成新 reqId，但要记录关联）
* V0.1 提供手动重试接口：`POST /api/devices/{deviceId}/commands/{reqId}/retry`

---

## 7. mqtt-gateway（Vert.x）设计

### 7.1 职责边界（非常重要）

网关只做：

* CONNECT 鉴权
* 在线会话管理
* Topic ACL
* 上行转发到 Core
* 下行从 Core 接收并转发给设备

网关不做：

* 复杂业务规则（低电量禁止移动等应该在 Core 做）
* 完整 Broker 的订阅路由体系

### 7.2 核心内存结构

* `sessions: Map<String, EndpointSession>`

  * deviceId
  * endpoint（连接句柄）
  * connectedAt / lastSeen
  * clientIp

### 7.3 连接处理（CONNECT）

1. 提取 clientId 作为 deviceId
2. 校验 username/password

  * V0.1 推荐：网关调用 Core 的 `GET /internal/auth?deviceId=...`（或把 secret 缓存到网关）
3. accept
4. 写 sessions
5. 通知 Core online

### 7.4 subscribe / publish 处理

* SUBSCRIBE 只允许 `pet/{deviceId}/cmd`
* PUBLISH 只允许：

  * `pet/{deviceId}/telemetry`
  * `pet/{deviceId}/cmd/ack`

收到 telemetry/ack：

* 校验 topic 与 deviceId 一致
* 解析 JSON（轻校验）
* HTTP POST 到 Core internal 接口

### 7.5 下行接口（Core → 网关）

网关提供内部接口：

* `POST /internal/command/send`

请求示例：

```json
{
  "deviceId": "pet001",
  "topic": "pet/pet001/cmd",
  "qos": 1,
  "payload": "{...json...}"
}
```

处理：

* sessions 有 endpoint → publish
* 无 endpoint → 返回 409（OFFLINE）

> V0.1 不做离线队列，下发失败由 Core 记录即可。

---

## 8. 设备端（轮式桌宠）实现规范（V0.1）

### 8.1 设备模块

* `mqtt_client`
* `command_handler`
* `motion_controller`
* `emotion_display`
* `telemetry_reporter`

### 8.2 动作安全限制（必须）

* speed 最大值（例如 0.7）
* durationMs 最大值（例如 3000ms）
* 命令执行互斥（执行 move 时收到新 move：要么 stop+move，要么拒绝 BUSY）

### 8.3 幂等策略（必须）

* 环形缓存最近 N 个 reqId（建议 N=32/64）
* 重复 reqId：

  * 不重复执行
  * 直接回 ack（code=“DUPLICATE” 或 DONE）

### 8.4 遥测上报频率

* 默认 2s 或 5s 上报一次（先选 5s，避免刷爆）
* 关键事件（比如低电量）立即上报 event（V0.2 再加）

---

## 9. 本地开发与启动

### 9.1 docker-compose（建议）

* PostgreSQL
* Redis（可选）

### 9.2 启动顺序

1. DB
2. pet-core
3. mqtt-gateway
4. 设备端连网关
5. 用 Swagger/Postman 下发命令

### 9.3 关键配置项

**pet-core**

* `db.url/user/pass`
* `gateway.baseUrl`（网关 internal 地址）
* `command.timeoutSec=10`
* `internal.token=...`（可选，内部回调鉴权）

**mqtt-gateway**

* `mqtt.port=1883`
* `internal.port=8081`
* `core.internalBaseUrl=http://pet-core:8080`
* `internal.token=...`（可选，内部回调鉴权）

---

## 10. 可观测性（最低限度就够用）

### 10.1 日志

* 网关：connect/disconnect、publish 上行摘要、下行 send 结果
* Core：command 生命周期、ack 处理、超时处理

### 10.2 指标（后期接 Prometheus）

V0.1 可以先打印日志，V0.2 加指标：

* 在线设备数
* cmd 下发成功/失败数
* ack 成功/失败/超时数
* telemetry 速率

---

## 11. 安全（V0.1 必做的最小集）

* 设备鉴权必须有：

  * username=deviceId
  * password=secret（或签名）
* internal 接口只允许内网访问
* topic ACL 必须严格校验 deviceId

---

## 12. 测试计划（V0.1 必做）

1. **协议测试**

* 模拟设备 publish telemetry/ack
* 验证 Core 状态变化正确

2. **压力冒烟**

* 100 次 move/stop 连续执行
* 断网重连（设备自动重连）

3. **异常**

* Core 重启（网关不断链；命令暂不可用可接受）
* 网关重启（设备重连；online 状态刷新）

---

## 13. 迭代路线（从 V0.1 往后怎么加）

* V0.2：行为状态机 + 定时卖萌 + 事件（触摸/碰撞/低电量）
* V0.3：TTS（先说话）
* V0.4：Spring AI（工具调用）

  * AI **只调用 Core API**（sendCommand/getState）
  * Core 做安全审核与限流（AI 不直接控电机）

---

# 你接下来最省力的落地顺序（建议照做）

1. **先写 pet-core**：DB + command 状态机 + internal 接口（可以先写假的网关 client）
2. **再写 mqtt-gateway**：CONNECT/ACL/转发/下发 internal API
3. **最后写设备端**：只做 move/stop/setEmotion + ack + telemetry
4. 用 Swagger/脚本验证闭环

---
