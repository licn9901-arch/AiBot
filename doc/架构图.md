下面我直接给你一份“**完整架构图 + 完整开发文档（可直接落到仓库 docs/）**”。整体按 **V0.1 MVP** 设计：先跑通闭环，不上来就复杂，但所有关键扩展点（多实例、消息队列、AI）都已经在架构里预留。

你可以把下面两段内容分别存成：

* `docs/ARCHITECTURE.md`（架构图+说明）
* `docs/DEVELOPMENT.md`（开发文档：接口、协议、数据、实现细则、测试与部署）

---

# ARCHITECTURE.md（完整架构图）

## 1. 总览架构图（组件视角）

> **说明**：V0.1 采用“Vert.x MQTT 网关 + Spring Boot Core”，网关负责连接/协议，Core 负责业务/数据。AI（Spring AI）作为后续独立服务插入，不影响 MVP。

```mermaid
flowchart LR
%% ====== Nodes ======
    subgraph DeviceSide["设备端(轮式桌宠)"]
        D1["Device MCU/ESP32\n- MQTT Client\n- Motion Controller\n- Emotion Display\n- Telemetry Reporter"]
    end

    subgraph Gateway["接入层：mqtt-gateway（Vert.x）"]
        G1["MQTT Server\n- Auth\n- Session Manager\n- Topic ACL\n- Publish/Subscribe Handler"]
        G2["(Session Map)\n设备连接表\ndeviceId -> endpoint"]
    end

    subgraph Core["业务层：pet-core（Spring Boot）"]
        C1["REST API\n/ 设备管理\n/ 指令下发\n/ 状态查询"]
        C2["Command Service\n状态机+超时"]
        C3["Telemetry Service\n最新状态缓存"]
        C4["Device Service\n注册+鉴权数据"]
        C5["(DB)\nPostgreSQL/MySQL"]
        C6["(Cache 可选)\nRedis"]
    end

    subgraph Console["控制端"]
        U1["Web Console / App / Postman"]
    end

    subgraph AI["后期扩展：pet-ai（Spring Boot + Spring AI）"]
        A1["Chat / Agent\nTool Calling"]
        A2["Tools:\ngetDeviceState\nsendCommand\nsetEmotion\n..."]
    end

%% ====== Flows ======
    U1 -->|HTTP/HTTPS| C1
    C1 --> C2
    C1 --> C4
    C2 --> C5
    C3 --> C5
    C4 --> C5
    C2 <--> C6
    C3 <--> C6

    D1 <-->|MQTT| G1
    G1 <--> G2

%% Internal integration
    G1 -->|Internal HTTP（V0.1）<br/>/ internal/telemetry<br/>/ internal/ack<br/>/ internal/online| C1
    C2 -->|Internal HTTP<br/>/ internal/command/send| G1

%% AI integration (later)
    A1 --> A2
    A2 -->|HTTP| C1
```

---

## 2. 部署架构图（运行与端口）

```mermaid
flowchart TB
  subgraph LANorCloud[局域网或云环境]
    subgraph Host1[服务器/VM]
      G[mqtt-gateway\nVert.x\n:1883 MQTT\n:8081 Internal]
      C[pet-core\nSpring Boot\n:8080 API/Internal]
      DB[(DB\nPostgreSQL/MySQL\n:5432/3306)]
      R[(Redis 可选\n:6379)]
    end

    subgraph Host2[可选：AI 主机]
      A[pet-ai\nSpring Boot + Spring AI\n:8090]
    end

    D[Device\nESP32/MCU\nWi-Fi]
    UI[Console/Web/App]
  end

  D <-- MQTT :1883 --> G
  UI <-- HTTPS :8080 --> C
  G <-- HTTP :8081/:8080 --> C
  C <-- SQL --> DB
  C <-- Redis --> R
  A <-- HTTP --> C
  UI <-- HTTP --> A
```

> V0.1 你可以把 `mqtt-gateway` 和 `pet-core` 放同一台机器上，内部接口走内网端口，先不考虑复杂网络。

---

## 3. 数据流图（上行/下行）

```mermaid
flowchart LR
  D[Device] -->|telemetry\npet\{id}/telemetry| G[mqtt-gateway]
  G -->|POST /internal/telemetry/{id}| C[pet-core]
  C -->|UPSERT latest + append history| DB[(DB/TSDB)]

  C -->|POST /internal/command/send| G
  G -->|cmd QoS1\npet/{id}/cmd| D
  D -->|cmd/ack QoS1\npet/{id}/cmd/ack| G
  G -->|POST /internal/ack/{id}| C
  C -->|update command status| DB
```

---

## 4. 核心时序图（连接上线）

```mermaid
sequenceDiagram
  autonumber
  participant D as Device
  participant G as mqtt-gateway (Vert.x)
  participant C as pet-core (Spring)
  participant DB as DB

  D->>G: CONNECT(clientId=deviceId, user/pass)
  G->>C: (可选) 校验设备密钥 /internal/auth
  C->>DB: 查 device + secretHash
  DB-->>C: OK/FAIL
  C-->>G: 允许/拒绝
  G-->>D: CONNACK(accepted)

  D->>G: SUBSCRIBE pet/{deviceId}/cmd
  G-->>D: SUBACK

  G->>C: POST /internal/gateway/deviceOnline
  C->>DB: 更新 device_session online=true
  DB-->>C: OK
```

---

## 5. 核心时序图（命令下发与回执闭环）

```mermaid
sequenceDiagram
  autonumber
  participant UI as Console/App
  participant C as pet-core (Spring)
  participant DB as DB
  participant G as mqtt-gateway (Vert.x)
  participant D as Device

  UI->>C: POST /api/devices/{id}/commands
  C->>DB: INSERT command(reqId,status=PENDING)
  DB-->>C: OK
  C->>G: POST /internal/command/send(reqId,...)
  G->>D: PUBLISH pet/{id}/cmd (QoS1)
  D-->>G: PUBACK (MQTT 协议层)
  D->>D: 执行动作 + 安全限制
  D->>G: PUBLISH pet/{id}/cmd/ack (QoS1, reqId, ok/code)
  G-->>D: PUBACK
  G->>C: POST /internal/ack/{id}
  C->>DB: UPDATE command status=ACKED/FAILED
  DB-->>C: OK
  C-->>UI: 200 OK (可轮询或SSE获取结果)
```

---

## 6. 数据模型图（ER）

```mermaid
erDiagram
  DEVICE ||--|| DEVICE_SESSION : has
  DEVICE ||--o{ COMMAND : receives
  DEVICE ||--|| TELEMETRY_LATEST : has

  DEVICE {
    string device_id PK
    string secret_hash
    string model
    string remark
    datetime created_at
  }

  DEVICE_SESSION {
    string device_id PK
    boolean online
    string gateway_instance_id
    string ip
    datetime last_seen
  }

  COMMAND {
    string req_id PK
    string device_id FK
    string type
    string payload_json
    string status
    string ack_code
    string ack_message
    datetime created_at
    datetime updated_at
  }

  TELEMETRY_LATEST {
    string device_id PK
    string telemetry_json
    datetime updated_at
  }
```

---
